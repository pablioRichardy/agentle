# generated by datamodel-codegen:
#   filename:  filtered_openapi.yaml
#   timestamp: 2025-10-18T15:02:20+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import AnyUrl, BaseModel, Extra, Field, confloat, conint, constr


class Type(Enum):
    approximate = "approximate"


class ApproximateLocation(BaseModel):
    type: Type = Field(
        ..., description="The type of location approximation. Always `approximate`."
    )
    country: Optional[str] = None
    region: Optional[str] = None
    city: Optional[str] = None
    timezone: Optional[str] = None


class ChatModel(Enum):
    gpt_5 = "gpt-5"
    gpt_5_mini = "gpt-5-mini"
    gpt_5_nano = "gpt-5-nano"
    gpt_5_2025_08_07 = "gpt-5-2025-08-07"
    gpt_5_mini_2025_08_07 = "gpt-5-mini-2025-08-07"
    gpt_5_nano_2025_08_07 = "gpt-5-nano-2025-08-07"
    gpt_5_chat_latest = "gpt-5-chat-latest"
    gpt_4_1 = "gpt-4.1"
    gpt_4_1_mini = "gpt-4.1-mini"
    gpt_4_1_nano = "gpt-4.1-nano"
    gpt_4_1_2025_04_14 = "gpt-4.1-2025-04-14"
    gpt_4_1_mini_2025_04_14 = "gpt-4.1-mini-2025-04-14"
    gpt_4_1_nano_2025_04_14 = "gpt-4.1-nano-2025-04-14"
    o4_mini = "o4-mini"
    o4_mini_2025_04_16 = "o4-mini-2025-04-16"
    o3 = "o3"
    o3_2025_04_16 = "o3-2025-04-16"
    o3_mini = "o3-mini"
    o3_mini_2025_01_31 = "o3-mini-2025-01-31"
    o1 = "o1"
    o1_2024_12_17 = "o1-2024-12-17"
    o1_preview = "o1-preview"
    o1_preview_2024_09_12 = "o1-preview-2024-09-12"
    o1_mini = "o1-mini"
    o1_mini_2024_09_12 = "o1-mini-2024-09-12"
    gpt_4o = "gpt-4o"
    gpt_4o_2024_11_20 = "gpt-4o-2024-11-20"
    gpt_4o_2024_08_06 = "gpt-4o-2024-08-06"
    gpt_4o_2024_05_13 = "gpt-4o-2024-05-13"
    gpt_4o_audio_preview = "gpt-4o-audio-preview"
    gpt_4o_audio_preview_2024_10_01 = "gpt-4o-audio-preview-2024-10-01"
    gpt_4o_audio_preview_2024_12_17 = "gpt-4o-audio-preview-2024-12-17"
    gpt_4o_audio_preview_2025_06_03 = "gpt-4o-audio-preview-2025-06-03"
    gpt_4o_mini_audio_preview = "gpt-4o-mini-audio-preview"
    gpt_4o_mini_audio_preview_2024_12_17 = "gpt-4o-mini-audio-preview-2024-12-17"
    gpt_4o_search_preview = "gpt-4o-search-preview"
    gpt_4o_mini_search_preview = "gpt-4o-mini-search-preview"
    gpt_4o_search_preview_2025_03_11 = "gpt-4o-search-preview-2025-03-11"
    gpt_4o_mini_search_preview_2025_03_11 = "gpt-4o-mini-search-preview-2025-03-11"
    chatgpt_4o_latest = "chatgpt-4o-latest"
    codex_mini_latest = "codex-mini-latest"
    gpt_4o_mini = "gpt-4o-mini"
    gpt_4o_mini_2024_07_18 = "gpt-4o-mini-2024-07-18"
    gpt_4_turbo = "gpt-4-turbo"
    gpt_4_turbo_2024_04_09 = "gpt-4-turbo-2024-04-09"
    gpt_4_0125_preview = "gpt-4-0125-preview"
    gpt_4_turbo_preview = "gpt-4-turbo-preview"
    gpt_4_1106_preview = "gpt-4-1106-preview"
    gpt_4_vision_preview = "gpt-4-vision-preview"
    gpt_4 = "gpt-4"
    gpt_4_0314 = "gpt-4-0314"
    gpt_4_0613 = "gpt-4-0613"
    gpt_4_32k = "gpt-4-32k"
    gpt_4_32k_0314 = "gpt-4-32k-0314"
    gpt_4_32k_0613 = "gpt-4-32k-0613"
    gpt_3_5_turbo = "gpt-3.5-turbo"
    gpt_3_5_turbo_16k = "gpt-3.5-turbo-16k"
    gpt_3_5_turbo_0301 = "gpt-3.5-turbo-0301"
    gpt_3_5_turbo_0613 = "gpt-3.5-turbo-0613"
    gpt_3_5_turbo_1106 = "gpt-3.5-turbo-1106"
    gpt_3_5_turbo_0125 = "gpt-3.5-turbo-0125"
    gpt_3_5_turbo_16k_0613 = "gpt-3.5-turbo-16k-0613"


class ClickButtonType(Enum):
    left = "left"
    right = "right"
    wheel = "wheel"
    back = "back"
    forward = "forward"


class Type1(Enum):
    click = "click"


class ClickParam(BaseModel):
    type: Literal["ClickParam"] = Field(
        ...,
        description="Specifies the event type. For a click action, this property is always `click`.",
    )
    button: ClickButtonType = Field(
        ...,
        description="Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.",
    )
    x: int = Field(..., description="The x-coordinate where the click occurred.")
    y: int = Field(..., description="The y-coordinate where the click occurred.")


class Type2(Enum):
    auto = "auto"


class CodeInterpreterContainerAuto(BaseModel):
    type: Type2 = Field(..., description="Always `auto`.")
    file_ids: Optional[List[str]] = Field(
        None,
        description="An optional list of uploaded files to make available to your code.",
        max_items=50,
    )


class Type3(Enum):
    image = "image"


class CodeInterpreterOutputImage(BaseModel):
    type: Literal["CodeInterpreterOutputImage"] = Field(
        ..., description="The type of the output. Always `image`."
    )
    url: str = Field(
        ..., description="The URL of the image output from the code interpreter."
    )


class Type4(Enum):
    logs = "logs"


class CodeInterpreterOutputLogs(BaseModel):
    type: Literal["CodeInterpreterOutputLogs"] = Field(
        ..., description="The type of the output. Always `logs`."
    )
    logs: str = Field(..., description="The logs output from the code interpreter.")


class Type5(Enum):
    code_interpreter = "code_interpreter"


class CodeInterpreterTool(BaseModel):
    type: Literal["CodeInterpreterTool"] = Field(
        ...,
        description="The type of the code interpreter tool. Always `code_interpreter`.\n",
    )
    container: Union[str, CodeInterpreterContainerAuto] = Field(
        ...,
        description="The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n",
    )


class Type6(Enum):
    code_interpreter_call = "code_interpreter_call"


class Status(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"
    interpreting = "interpreting"
    failed = "failed"


class Outputs(BaseModel):
    __root__: Union[CodeInterpreterOutputLogs, CodeInterpreterOutputImage] = Field(
        ..., discriminator="type"
    )


class CodeInterpreterToolCall(BaseModel):
    type: Literal["CodeInterpreterToolCall"] = Field(
        ...,
        description="The type of the code interpreter tool call. Always `code_interpreter_call`.\n",
    )
    id: str = Field(
        ..., description="The unique ID of the code interpreter tool call.\n"
    )
    status: Status = Field(
        ...,
        description="The status of the code interpreter tool call. Valid values are `in_progress`, `completed`, `incomplete`, `interpreting`, and `failed`.\n",
    )
    container_id: str = Field(
        ..., description="The ID of the container used to run the code.\n"
    )
    code: Optional[str]
    outputs: Optional[List[Outputs]]


class Type7(Enum):
    eq = "eq"
    ne = "ne"
    gt = "gt"
    gte = "gte"
    lt = "lt"
    lte = "lte"


class ComparisonFilterValueItems(BaseModel):
    __root__: Union[str, float]


class Type8(Enum):
    and_ = "and"
    or_ = "or"


class Type9(Enum):
    computer_call_output = "computer_call_output"


class ComputerCallSafetyCheckParam(BaseModel):
    id: str = Field(..., description="The ID of the pending safety check.")
    code: Optional[str] = None
    message: Optional[str] = None


class ComputerEnvironment(Enum):
    windows = "windows"
    mac = "mac"
    linux = "linux"
    ubuntu = "ubuntu"
    browser = "browser"


class Type10(Enum):
    computer_screenshot = "computer_screenshot"


class ComputerScreenshotImage(BaseModel):
    type: Type10 = Field(
        ...,
        description="Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n",
    )
    image_url: Optional[str] = Field(
        None, description="The URL of the screenshot image."
    )
    file_id: Optional[str] = Field(
        None,
        description="The identifier of an uploaded file that contains the screenshot.",
    )


class Type11(Enum):
    computer_call = "computer_call"


class Status1(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"


class Type12(Enum):
    computer_use_preview = "computer_use_preview"


class ComputerUsePreviewTool(BaseModel):
    type: Literal["ComputerUsePreviewTool"] = Field(
        ...,
        description="The type of the computer use tool. Always `computer_use_preview`.",
    )
    environment: ComputerEnvironment = Field(
        ..., description="The type of computer environment to control."
    )
    display_width: int = Field(..., description="The width of the computer display.")
    display_height: int = Field(..., description="The height of the computer display.")


class Type13(Enum):
    container_file_citation = "container_file_citation"


class ContainerFileCitationBody(BaseModel):
    type: Literal["ContainerFileCitationBody"] = Field(
        ...,
        description="The type of the container file citation. Always `container_file_citation`.",
    )
    container_id: str = Field(..., description="The ID of the container file.")
    file_id: str = Field(..., description="The ID of the file.")
    start_index: int = Field(
        ...,
        description="The index of the first character of the container file citation in the message.",
    )
    end_index: int = Field(
        ...,
        description="The index of the last character of the container file citation in the message.",
    )
    filename: str = Field(..., description="The filename of the container file cited.")


class Conversation2(BaseModel):
    id: str = Field(..., description="The unique ID of the conversation.")


class ConversationParam(BaseModel):
    id: str = Field(
        ..., description="The unique ID of the conversation.", example="conv_123"
    )


class Type14(Enum):
    grammar = "grammar"


class Type15(Enum):
    text = "text"


class CustomTextFormatParam(BaseModel):
    type: Literal["CustomTextFormatParam"] = Field(
        ..., description="Unconstrained text format. Always `text`."
    )


class Type16(Enum):
    custom_tool_call = "custom_tool_call"


class CustomToolCall(BaseModel):
    type: Literal["CustomToolCall"] = Field(
        ...,
        description="The type of the custom tool call. Always `custom_tool_call`.\n",
    )
    id: Optional[str] = Field(
        None,
        description="The unique ID of the custom tool call in the OpenAI platform.\n",
    )
    call_id: str = Field(
        ...,
        description="An identifier used to map this custom tool call to a tool call output.\n",
    )
    name: str = Field(..., description="The name of the custom tool being called.\n")
    input: str = Field(
        ..., description="The input for the custom tool call generated by the model.\n"
    )


class Type17(Enum):
    custom_tool_call_output = "custom_tool_call_output"


class Type18(Enum):
    custom = "custom"


class DetailEnum(Enum):
    low = "low"
    high = "high"
    auto = "auto"


class Type19(Enum):
    double_click = "double_click"


class DoubleClickAction(BaseModel):
    type: Literal["DoubleClickAction"] = Field(
        ...,
        description="Specifies the event type. For a double click action, this property is always set to `double_click`.",
    )
    x: int = Field(..., description="The x-coordinate where the double click occurred.")
    y: int = Field(..., description="The y-coordinate where the double click occurred.")


class Type20(Enum):
    drag = "drag"


class DragPoint(BaseModel):
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class Role(Enum):
    user = "user"
    assistant = "assistant"
    system = "system"
    developer = "developer"


class Type21(Enum):
    message = "message"


class Type22(Enum):
    file_citation = "file_citation"


class FileCitationBody(BaseModel):
    type: Literal["FileCitationBody"] = Field(
        ..., description="The type of the file citation. Always `file_citation`."
    )
    file_id: str = Field(..., description="The ID of the file.")
    index: int = Field(..., description="The index of the file in the list of files.")
    filename: str = Field(..., description="The filename of the file cited.")


class Type23(Enum):
    file_path = "file_path"


class FilePath(BaseModel):
    type: Literal["FilePath"] = Field(
        ..., description="The type of the file path. Always `file_path`.\n"
    )
    file_id: str = Field(..., description="The ID of the file.\n")
    index: int = Field(..., description="The index of the file in the list of files.\n")


class Type24(Enum):
    file_search = "file_search"


class Type25(Enum):
    file_search_call = "file_search_call"


class Status2(Enum):
    in_progress = "in_progress"
    searching = "searching"
    completed = "completed"
    incomplete = "incomplete"
    failed = "failed"


class FunctionCallItemStatus(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"


class Type26(Enum):
    function_call_output = "function_call_output"


class Type27(Enum):
    function = "function"


class FunctionTool(BaseModel):
    type: Literal["FunctionTool"] = Field(
        ..., description="The type of the function tool. Always `function`."
    )
    name: str = Field(..., description="The name of the function to call.")
    description: Optional[str] = None
    parameters: Optional[Dict[str, Any]]
    strict: Optional[bool]


class Type28(Enum):
    function_call = "function_call"


class Status3(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"


class FunctionToolCall(BaseModel):
    id: Optional[str] = Field(
        None, description="The unique ID of the function tool call.\n"
    )
    type: Literal["FunctionToolCall"] = Field(
        ..., description="The type of the function tool call. Always `function_call`.\n"
    )
    call_id: str = Field(
        ...,
        description="The unique ID of the function tool call generated by the model.\n",
    )
    name: str = Field(..., description="The name of the function to run.\n")
    arguments: str = Field(
        ..., description="A JSON string of the arguments to pass to the function.\n"
    )
    status: Optional[Status3] = Field(
        None,
        description="The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n",
    )


class GrammarSyntax1(Enum):
    lark = "lark"
    regex = "regex"


class ImageDetail(Enum):
    low = "low"
    high = "high"
    auto = "auto"


class Type29(Enum):
    image_generation = "image_generation"


class Model(Enum):
    gpt_image_1 = "gpt-image-1"
    gpt_image_1_mini = "gpt-image-1-mini"


class Quality(Enum):
    low = "low"
    medium = "medium"
    high = "high"
    auto = "auto"


class Size(Enum):
    field_1024x1024 = "1024x1024"
    field_1024x1536 = "1024x1536"
    field_1536x1024 = "1536x1024"
    auto = "auto"


class OutputFormat(Enum):
    png = "png"
    webp = "webp"
    jpeg = "jpeg"


class Moderation(Enum):
    auto = "auto"
    low = "low"


class Background(Enum):
    transparent = "transparent"
    opaque = "opaque"
    auto = "auto"


class InputImageMask(BaseModel):
    class Config:
        extra = Extra.forbid

    image_url: Optional[str] = Field(None, description="Base64-encoded mask image.\n")
    file_id: Optional[str] = Field(None, description="File ID for the mask image.\n")


class Type30(Enum):
    image_generation_call = "image_generation_call"


class Status4(Enum):
    in_progress = "in_progress"
    completed = "completed"
    generating = "generating"
    failed = "failed"


class ImageGenToolCall(BaseModel):
    type: Literal["ImageGenToolCall"] = Field(
        ...,
        description="The type of the image generation call. Always `image_generation_call`.\n",
    )
    id: str = Field(..., description="The unique ID of the image generation call.\n")
    status: Status4 = Field(
        ..., description="The status of the image generation call.\n"
    )
    result: Optional[str]


class IncludeEnum(Enum):
    file_search_call_results = "file_search_call.results"
    web_search_call_results = "web_search_call.results"
    web_search_call_action_sources = "web_search_call.action.sources"
    message_input_image_image_url = "message.input_image.image_url"
    computer_call_output_output_image_url = "computer_call_output.output.image_url"
    code_interpreter_call_outputs = "code_interpreter_call.outputs"
    reasoning_encrypted_content = "reasoning.encrypted_content"
    message_output_text_logprobs = "message.output_text.logprobs"


class Type31(Enum):
    input_audio = "input_audio"


class Format(Enum):
    mp3 = "mp3"
    wav = "wav"


class InputAudio1(BaseModel):
    data: str = Field(..., description="Base64-encoded audio data.\n")
    format: Format = Field(
        ...,
        description="The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n",
    )


class InputAudio(BaseModel):
    type: Literal["InputAudio"] = Field(
        ..., description="The type of the input item. Always `input_audio`.\n"
    )
    input_audio: InputAudio1


class InputFidelity(Enum):
    high = "high"
    low = "low"


class Type32(Enum):
    input_file = "input_file"


class InputFileContent(BaseModel):
    type: Literal["InputFileContent"] = Field(
        ..., description="The type of the input item. Always `input_file`."
    )
    file_id: Optional[str] = None
    filename: Optional[str] = Field(
        None, description="The name of the file to be sent to the model."
    )
    file_url: Optional[str] = Field(
        None, description="The URL of the file to be sent to the model."
    )
    file_data: Optional[str] = Field(
        None, description="The content of the file to be sent to the model.\n"
    )


class InputFileContentParam(BaseModel):
    type: Literal["InputFileContentParam"] = Field(
        ..., description="The type of the input item. Always `input_file`."
    )
    file_id: Optional[str] = None
    filename: Optional[str] = None
    file_data: Optional[constr(max_length=33554432)] = None
    file_url: Optional[str] = None


class Type34(Enum):
    input_image = "input_image"


class InputImageContent(BaseModel):
    type: Literal["InputImageContent"] = Field(
        ..., description="The type of the input item. Always `input_image`."
    )
    image_url: Optional[str] = None
    file_id: Optional[str] = None
    detail: ImageDetail = Field(
        ...,
        description="The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.",
    )


class InputImageContentParamAutoParam(BaseModel):
    type: Literal["InputImageContentParamAutoParam"] = Field(
        ..., description="The type of the input item. Always `input_image`."
    )
    image_url: Optional[constr(max_length=20971520)] = None
    file_id: Optional[str] = None
    detail: Optional[DetailEnum] = None


class Type36(Enum):
    message = "message"


class Role1(Enum):
    user = "user"
    system = "system"
    developer = "developer"


class Status5(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"


class Type37(Enum):
    input_text = "input_text"


class InputTextContent(BaseModel):
    type: Literal["InputTextContent"] = Field(
        ..., description="The type of the input item. Always `input_text`."
    )
    text: str = Field(..., description="The text input to the model.")


class InputTextContentParam(BaseModel):
    type: Literal["InputTextContentParam"] = Field(
        ..., description="The type of the input item. Always `input_text`."
    )
    text: constr(max_length=10485760) = Field(
        ..., description="The text input to the model."
    )


class Type39(Enum):
    item_reference = "item_reference"


class ItemReferenceParam(BaseModel):
    type: Literal["ItemReferenceParam"]
    id: str = Field(..., description="The ID of the item to reference.")


class Type40(Enum):
    keypress = "keypress"


class KeyPressAction(BaseModel):
    type: Literal["KeyPressAction"] = Field(
        ...,
        description="Specifies the event type. For a keypress action, this property is always set to `keypress`.",
    )
    keys: List[str] = Field(
        ...,
        description="The combination of keys the model is requesting to be pressed. This is an array of strings, each representing a key.",
    )


class Type41(Enum):
    exec = "exec"


class LocalShellExecAction(BaseModel):
    type: Type41 = Field(
        ..., description="The type of the local shell action. Always `exec`."
    )
    command: List[str] = Field(..., description="The command to run.")
    timeout_ms: Optional[int] = None
    working_directory: Optional[str] = None
    env: Dict[str, str] = Field(
        ..., description="Environment variables to set for the command."
    )
    user: Optional[str] = None


class Type42(Enum):
    local_shell_call = "local_shell_call"


class LocalShellToolCall(BaseModel):
    type: Literal["LocalShellToolCall"] = Field(
        ...,
        description="The type of the local shell call. Always `local_shell_call`.\n",
    )
    id: str = Field(..., description="The unique ID of the local shell call.\n")
    call_id: str = Field(
        ...,
        description="The unique ID of the local shell tool call generated by the model.\n",
    )
    action: LocalShellExecAction
    status: Status5 = Field(..., description="The status of the local shell call.\n")


class Type43(Enum):
    local_shell_call_output = "local_shell_call_output"


class LocalShellToolCallOutput(BaseModel):
    type: Literal["LocalShellToolCallOutput"] = Field(
        ...,
        description="The type of the local shell tool call output. Always `local_shell_call_output`.\n",
    )
    id: str = Field(
        ...,
        description="The unique ID of the local shell tool call generated by the model.\n",
    )
    output: str = Field(
        ..., description="A JSON string of the output of the local shell tool call.\n"
    )
    status: Optional[Status5] = None


class Type44(Enum):
    local_shell = "local_shell"


class LocalShellToolParam(BaseModel):
    type: Literal["LocalShellToolParam"] = Field(
        ..., description="The type of the local shell tool. Always `local_shell`."
    )


class Type45(Enum):
    mcp_approval_request = "mcp_approval_request"


class MCPApprovalRequest(BaseModel):
    type: Literal["MCPApprovalRequest"] = Field(
        ..., description="The type of the item. Always `mcp_approval_request`.\n"
    )
    id: str = Field(..., description="The unique ID of the approval request.\n")
    server_label: str = Field(
        ..., description="The label of the MCP server making the request.\n"
    )
    name: str = Field(..., description="The name of the tool to run.\n")
    arguments: str = Field(
        ..., description="A JSON string of arguments for the tool.\n"
    )


class Type46(Enum):
    mcp_approval_response = "mcp_approval_response"


class MCPApprovalResponse(BaseModel):
    type: Literal["MCPApprovalResponse"] = Field(
        ..., description="The type of the item. Always `mcp_approval_response`.\n"
    )
    id: Optional[str] = None
    approval_request_id: str = Field(
        ..., description="The ID of the approval request being answered.\n"
    )
    approve: bool = Field(..., description="Whether the request was approved.\n")
    reason: Optional[str] = None


class Type47(Enum):
    mcp_list_tools = "mcp_list_tools"


class MCPListToolsTool(BaseModel):
    name: str = Field(..., description="The name of the tool.\n")
    description: Optional[str] = None
    input_schema: Dict[str, Any] = Field(
        ..., description="The JSON schema describing the tool's input.\n"
    )
    annotations: Optional[Dict[str, Any]] = None


class Type48(Enum):
    mcp = "mcp"


class ConnectorId(Enum):
    connector_dropbox = "connector_dropbox"
    connector_gmail = "connector_gmail"
    connector_googlecalendar = "connector_googlecalendar"
    connector_googledrive = "connector_googledrive"
    connector_microsoftteams = "connector_microsoftteams"
    connector_outlookcalendar = "connector_outlookcalendar"
    connector_outlookemail = "connector_outlookemail"
    connector_sharepoint = "connector_sharepoint"


class RequireApproval1(Enum):
    always = "always"
    never = "never"


class Type49(Enum):
    mcp_call = "mcp_call"


class MCPToolCallStatus(Enum):
    in_progress = "in_progress"
    completed = "completed"
    incomplete = "incomplete"
    calling = "calling"
    failed = "failed"


class MCPToolFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    tool_names: Optional[List[str]] = Field(
        None, description="List of allowed tool names.", title="MCP allowed tools"
    )
    read_only: Optional[bool] = Field(
        None,
        description="Indicates whether or not a tool modifies data or is read-only. If an\nMCP server is [annotated with `readOnlyHint`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\nit will match this filter.\n",
    )


class Metadata(BaseModel):
    __root__: Optional[Dict[str, str]]


class ModelIdsResponses1(Enum):
    o1_pro = "o1-pro"
    o1_pro_2025_03_19 = "o1-pro-2025-03-19"
    o3_pro = "o3-pro"
    o3_pro_2025_06_10 = "o3-pro-2025-06-10"
    o3_deep_research = "o3-deep-research"
    o3_deep_research_2025_06_26 = "o3-deep-research-2025-06-26"
    o4_mini_deep_research = "o4-mini-deep-research"
    o4_mini_deep_research_2025_06_26 = "o4-mini-deep-research-2025-06-26"
    computer_use_preview = "computer-use-preview"
    computer_use_preview_2025_03_11 = "computer-use-preview-2025-03-11"
    gpt_5_codex = "gpt-5-codex"
    gpt_5_pro = "gpt-5-pro"
    gpt_5_pro_2025_10_06 = "gpt-5-pro-2025-10-06"


class ModelIdsShared(BaseModel):
    __root__: Union[str, ChatModel] = Field(..., example="gpt-4o")


class Type50(Enum):
    move = "move"


class Move(BaseModel):
    type: Literal["Move"] = Field(
        ...,
        description="Specifies the event type. For a move action, this property is \nalways set to `move`.\n",
    )
    x: int = Field(..., description="The x-coordinate to move to.\n")
    y: int = Field(..., description="The y-coordinate to move to.\n")


class Type51(Enum):
    message = "message"


class Role2(Enum):
    assistant = "assistant"


class Type52(Enum):
    output_text = "output_text"


class RankerVersionType(Enum):
    auto = "auto"
    default_2024_11_15 = "default-2024-11-15"


class RankingOptions(BaseModel):
    ranker: Optional[RankerVersionType] = Field(
        None, description="The ranker to use for the file search."
    )
    score_threshold: Optional[float] = Field(
        None,
        description="The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results.",
    )


class Summary(Enum):
    auto = "auto"
    concise = "concise"
    detailed = "detailed"


class GenerateSummary(Enum):
    auto = "auto"
    concise = "concise"
    detailed = "detailed"


class ReasoningEffort1(Enum):
    minimal = "minimal"
    low = "low"
    medium = "medium"
    high = "high"


class ReasoningEffort(BaseModel):
    __root__: Optional[ReasoningEffort1]


class Type53(Enum):
    reasoning = "reasoning"


class Type54(Enum):
    reasoning_text = "reasoning_text"


class ReasoningTextContent(BaseModel):
    type: Literal["ReasoningTextContent"] = Field(
        ..., description="The type of the reasoning text. Always `reasoning_text`."
    )
    text: str = Field(..., description="The reasoning text from the model.")


class Type55(Enum):
    refusal = "refusal"


class RefusalContent(BaseModel):
    type: Literal["RefusalContent"] = Field(
        ..., description="The type of the refusal. Always `refusal`."
    )
    refusal: str = Field(..., description="The refusal explanation from the model.")


class Object(Enum):
    response = "response"


class Status10(Enum):
    completed = "completed"
    failed = "failed"
    in_progress = "in_progress"
    cancelled = "cancelled"
    queued = "queued"
    incomplete = "incomplete"


class Reason(Enum):
    max_output_tokens = "max_output_tokens"
    content_filter = "content_filter"


class IncompleteDetails(BaseModel):
    reason: Optional[Reason] = Field(
        None, description="The reason why the response is incomplete."
    )


class Type56(Enum):
    response_audio_delta = "response.audio.delta"


class ResponseAudioDeltaEvent(BaseModel):
    type: Literal["ResponseAudioDeltaEvent"] = Field(
        ..., description="The type of the event. Always `response.audio.delta`.\n"
    )
    sequence_number: int = Field(
        ..., description="A sequence number for this chunk of the stream response.\n"
    )
    delta: str = Field(
        ..., description="A chunk of Base64 encoded response audio bytes.\n"
    )


class Type57(Enum):
    response_audio_done = "response.audio.done"


class ResponseAudioDoneEvent(BaseModel):
    type: Literal["ResponseAudioDoneEvent"] = Field(
        ..., description="The type of the event. Always `response.audio.done`.\n"
    )
    sequence_number: int = Field(..., description="The sequence number of the delta.\n")


class Type58(Enum):
    response_audio_transcript_delta = "response.audio.transcript.delta"


class ResponseAudioTranscriptDeltaEvent(BaseModel):
    type: Literal["ResponseAudioTranscriptDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always `response.audio.transcript.delta`.\n",
    )
    delta: str = Field(
        ..., description="The partial transcript of the audio response.\n"
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type59(Enum):
    response_audio_transcript_done = "response.audio.transcript.done"


class ResponseAudioTranscriptDoneEvent(BaseModel):
    type: Literal["ResponseAudioTranscriptDoneEvent"] = Field(
        ...,
        description="The type of the event. Always `response.audio.transcript.done`.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type60(Enum):
    response_code_interpreter_call_code_delta = (
        "response.code_interpreter_call_code.delta"
    )


class ResponseCodeInterpreterCallCodeDeltaEvent(BaseModel):
    type: Literal["ResponseCodeInterpreterCallCodeDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always `response.code_interpreter_call_code.delta`.",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item in the response for which the code is being streamed.",
    )
    item_id: str = Field(
        ..., description="The unique identifier of the code interpreter tool call item."
    )
    delta: str = Field(
        ...,
        description="The partial code snippet being streamed by the code interpreter.",
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of this event, used to order streaming events.",
    )


class Type61(Enum):
    response_code_interpreter_call_code_done = (
        "response.code_interpreter_call_code.done"
    )


class ResponseCodeInterpreterCallCodeDoneEvent(BaseModel):
    type: Literal["ResponseCodeInterpreterCallCodeDoneEvent"] = Field(
        ...,
        description="The type of the event. Always `response.code_interpreter_call_code.done`.",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item in the response for which the code is finalized.",
    )
    item_id: str = Field(
        ..., description="The unique identifier of the code interpreter tool call item."
    )
    code: str = Field(
        ..., description="The final code snippet output by the code interpreter."
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of this event, used to order streaming events.",
    )


class Type62(Enum):
    response_code_interpreter_call_completed = (
        "response.code_interpreter_call.completed"
    )


class ResponseCodeInterpreterCallCompletedEvent(BaseModel):
    type: Literal["ResponseCodeInterpreterCallCompletedEvent"] = Field(
        ...,
        description="The type of the event. Always `response.code_interpreter_call.completed`.",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item in the response for which the code interpreter call is completed.",
    )
    item_id: str = Field(
        ..., description="The unique identifier of the code interpreter tool call item."
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of this event, used to order streaming events.",
    )


class Type63(Enum):
    response_code_interpreter_call_in_progress = (
        "response.code_interpreter_call.in_progress"
    )


class ResponseCodeInterpreterCallInProgressEvent(BaseModel):
    type: Literal["ResponseCodeInterpreterCallInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always `response.code_interpreter_call.in_progress`.",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item in the response for which the code interpreter call is in progress.",
    )
    item_id: str = Field(
        ..., description="The unique identifier of the code interpreter tool call item."
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of this event, used to order streaming events.",
    )


class Type64(Enum):
    response_code_interpreter_call_interpreting = (
        "response.code_interpreter_call.interpreting"
    )


class ResponseCodeInterpreterCallInterpretingEvent(BaseModel):
    type: Literal["ResponseCodeInterpreterCallInterpretingEvent"] = Field(
        ...,
        description="The type of the event. Always `response.code_interpreter_call.interpreting`.",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item in the response for which the code interpreter is interpreting code.",
    )
    item_id: str = Field(
        ..., description="The unique identifier of the code interpreter tool call item."
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of this event, used to order streaming events.",
    )


class Type65(Enum):
    response_completed = "response.completed"


class Type66(Enum):
    response_content_part_added = "response.content_part.added"


class Type67(Enum):
    response_content_part_done = "response.content_part.done"


class Type68(Enum):
    response_created = "response.created"


class Type69(Enum):
    response_custom_tool_call_input_delta = "response.custom_tool_call_input.delta"


class ResponseCustomToolCallInputDeltaEvent(BaseModel):
    type: Literal["ResponseCustomToolCallInputDeltaEvent"] = Field(
        ..., description="The event type identifier."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    output_index: int = Field(
        ..., description="The index of the output this delta applies to."
    )
    item_id: str = Field(
        ...,
        description="Unique identifier for the API item associated with this event.",
    )
    delta: str = Field(
        ..., description="The incremental input data (delta) for the custom tool call."
    )


class Type70(Enum):
    response_custom_tool_call_input_done = "response.custom_tool_call_input.done"


class ResponseCustomToolCallInputDoneEvent(BaseModel):
    type: Literal["ResponseCustomToolCallInputDoneEvent"] = Field(
        ..., description="The event type identifier."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    output_index: int = Field(
        ..., description="The index of the output this event applies to."
    )
    item_id: str = Field(
        ...,
        description="Unique identifier for the API item associated with this event.",
    )
    input: str = Field(
        ..., description="The complete input data for the custom tool call."
    )


class ResponseErrorCode(Enum):
    server_error = "server_error"
    rate_limit_exceeded = "rate_limit_exceeded"
    invalid_prompt = "invalid_prompt"
    vector_store_timeout = "vector_store_timeout"
    invalid_image = "invalid_image"
    invalid_image_format = "invalid_image_format"
    invalid_base64_image = "invalid_base64_image"
    invalid_image_url = "invalid_image_url"
    image_too_large = "image_too_large"
    image_too_small = "image_too_small"
    image_parse_error = "image_parse_error"
    image_content_policy_violation = "image_content_policy_violation"
    invalid_image_mode = "invalid_image_mode"
    image_file_too_large = "image_file_too_large"
    unsupported_image_media_type = "unsupported_image_media_type"
    empty_image_file = "empty_image_file"
    failed_to_download_image = "failed_to_download_image"
    image_file_not_found = "image_file_not_found"


class Type71(Enum):
    error = "error"


class ResponseErrorEvent(BaseModel):
    type: Literal["ResponseErrorEvent"] = Field(
        ..., description="The type of the event. Always `error`.\n"
    )
    code: Optional[str]
    message: str = Field(..., description="The error message.\n")
    param: Optional[str]
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type72(Enum):
    response_failed = "response.failed"


class Type73(Enum):
    response_file_search_call_completed = "response.file_search_call.completed"


class ResponseFileSearchCallCompletedEvent(BaseModel):
    type: Literal["ResponseFileSearchCallCompletedEvent"] = Field(
        ...,
        description="The type of the event. Always `response.file_search_call.completed`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the file search call is initiated.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the file search call is initiated.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type74(Enum):
    response_file_search_call_in_progress = "response.file_search_call.in_progress"


class ResponseFileSearchCallInProgressEvent(BaseModel):
    type: Literal["ResponseFileSearchCallInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always `response.file_search_call.in_progress`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the file search call is initiated.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the file search call is initiated.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type75(Enum):
    response_file_search_call_searching = "response.file_search_call.searching"


class ResponseFileSearchCallSearchingEvent(BaseModel):
    type: Literal["ResponseFileSearchCallSearchingEvent"] = Field(
        ...,
        description="The type of the event. Always `response.file_search_call.searching`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the file search call is searching.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the file search call is initiated.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type76(Enum):
    json_object = "json_object"


class ResponseFormatJsonObject(BaseModel):
    type: Literal["ResponseFormatJsonObject"] = Field(
        ...,
        description="The type of response format being defined. Always `json_object`.",
    )


class ResponseFormatJsonSchemaSchema(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class Type77(Enum):
    text = "text"


class ResponseFormatText(BaseModel):
    type: Literal["ResponseFormatText"] = Field(
        ..., description="The type of response format being defined. Always `text`."
    )


class Type78(Enum):
    response_function_call_arguments_delta = "response.function_call_arguments.delta"


class ResponseFunctionCallArgumentsDeltaEvent(BaseModel):
    type: Literal["ResponseFunctionCallArgumentsDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always `response.function_call_arguments.delta`.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the function-call arguments delta is added to.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the function-call arguments delta is added to.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    delta: str = Field(
        ..., description="The function-call arguments delta that is added.\n"
    )


class Type79(Enum):
    response_function_call_arguments_done = "response.function_call_arguments.done"


class ResponseFunctionCallArgumentsDoneEvent(BaseModel):
    type: Literal["ResponseFunctionCallArgumentsDoneEvent"]
    item_id: str = Field(..., description="The ID of the item.")
    name: str = Field(..., description="The name of the function that was called.")
    output_index: int = Field(..., description="The index of the output item.")
    sequence_number: int = Field(..., description="The sequence number of this event.")
    arguments: str = Field(..., description="The function-call arguments.")


class Type80(Enum):
    response_image_generation_call_completed = (
        "response.image_generation_call.completed"
    )


class ResponseImageGenCallCompletedEvent(BaseModel):
    type: Literal["ResponseImageGenCallCompletedEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.image_generation_call.completed'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    item_id: str = Field(
        ...,
        description="The unique identifier of the image generation item being processed.",
    )


class Type81(Enum):
    response_image_generation_call_generating = (
        "response.image_generation_call.generating"
    )


class ResponseImageGenCallGeneratingEvent(BaseModel):
    type: Literal["ResponseImageGenCallGeneratingEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.image_generation_call.generating'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the image generation item being processed.",
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of the image generation item being processed.",
    )


class Type82(Enum):
    response_image_generation_call_in_progress = (
        "response.image_generation_call.in_progress"
    )


class ResponseImageGenCallInProgressEvent(BaseModel):
    type: Literal["ResponseImageGenCallInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.image_generation_call.in_progress'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the image generation item being processed.",
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of the image generation item being processed.",
    )


class Type83(Enum):
    response_image_generation_call_partial_image = (
        "response.image_generation_call.partial_image"
    )


class ResponseImageGenCallPartialImageEvent(BaseModel):
    type: Literal["ResponseImageGenCallPartialImageEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.image_generation_call.partial_image'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the image generation item being processed.",
    )
    sequence_number: int = Field(
        ...,
        description="The sequence number of the image generation item being processed.",
    )
    partial_image_index: int = Field(
        ...,
        description="0-based index for the partial image (backend is 1-based, but this is 0-based for the user).",
    )
    partial_image_b64: str = Field(
        ...,
        description="Base64-encoded partial image data, suitable for rendering as an image.",
    )


class Type84(Enum):
    response_in_progress = "response.in_progress"


class Type85(Enum):
    response_incomplete = "response.incomplete"


class TopLogprob(BaseModel):
    token: Optional[str] = Field(None, description="A possible text token.")
    logprob: Optional[float] = Field(
        None, description="The log probability of this token."
    )


class ResponseLogProb(BaseModel):
    token: str = Field(..., description="A possible text token.")
    logprob: float = Field(..., description="The log probability of this token.\n")
    top_logprobs: Optional[List[TopLogprob]] = Field(
        None, description="The log probability of the top 20 most likely tokens.\n"
    )


class Type86(Enum):
    response_mcp_call_arguments_delta = "response.mcp_call_arguments.delta"


class ResponseMCPCallArgumentsDeltaEvent(BaseModel):
    type: Literal["ResponseMCPCallArgumentsDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_call_arguments.delta'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the MCP tool call item being processed.",
    )
    delta: str = Field(
        ...,
        description="A JSON string containing the partial update to the arguments for the MCP tool call.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type87(Enum):
    response_mcp_call_arguments_done = "response.mcp_call_arguments.done"


class ResponseMCPCallArgumentsDoneEvent(BaseModel):
    type: Literal["ResponseMCPCallArgumentsDoneEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_call_arguments.done'.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the MCP tool call item being processed.",
    )
    arguments: str = Field(
        ...,
        description="A JSON string containing the finalized arguments for the MCP tool call.\n",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type88(Enum):
    response_mcp_call_completed = "response.mcp_call.completed"


class ResponseMCPCallCompletedEvent(BaseModel):
    type: Literal["ResponseMCPCallCompletedEvent"] = Field(
        ..., description="The type of the event. Always 'response.mcp_call.completed'."
    )
    item_id: str = Field(
        ..., description="The ID of the MCP tool call item that completed."
    )
    output_index: int = Field(
        ..., description="The index of the output item that completed."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type89(Enum):
    response_mcp_call_failed = "response.mcp_call.failed"


class ResponseMCPCallFailedEvent(BaseModel):
    type: Literal["ResponseMCPCallFailedEvent"] = Field(
        ..., description="The type of the event. Always 'response.mcp_call.failed'."
    )
    item_id: str = Field(
        ..., description="The ID of the MCP tool call item that failed."
    )
    output_index: int = Field(
        ..., description="The index of the output item that failed."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type90(Enum):
    response_mcp_call_in_progress = "response.mcp_call.in_progress"


class ResponseMCPCallInProgressEvent(BaseModel):
    type: Literal["ResponseMCPCallInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_call.in_progress'.",
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the MCP tool call item being processed.",
    )


class Type91(Enum):
    response_mcp_list_tools_completed = "response.mcp_list_tools.completed"


class ResponseMCPListToolsCompletedEvent(BaseModel):
    type: Literal["ResponseMCPListToolsCompletedEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_list_tools.completed'.",
    )
    item_id: str = Field(
        ..., description="The ID of the MCP tool call item that produced this output."
    )
    output_index: int = Field(
        ..., description="The index of the output item that was processed."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type92(Enum):
    response_mcp_list_tools_failed = "response.mcp_list_tools.failed"


class ResponseMCPListToolsFailedEvent(BaseModel):
    type: Literal["ResponseMCPListToolsFailedEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_list_tools.failed'.",
    )
    item_id: str = Field(
        ..., description="The ID of the MCP tool call item that failed."
    )
    output_index: int = Field(
        ..., description="The index of the output item that failed."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type93(Enum):
    response_mcp_list_tools_in_progress = "response.mcp_list_tools.in_progress"


class ResponseMCPListToolsInProgressEvent(BaseModel):
    type: Literal["ResponseMCPListToolsInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.mcp_list_tools.in_progress'.",
    )
    item_id: str = Field(
        ..., description="The ID of the MCP tool call item that is being processed."
    )
    output_index: int = Field(
        ..., description="The index of the output item that is being processed."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")


class Type94(Enum):
    response_output_item_added = "response.output_item.added"


class Type95(Enum):
    response_output_item_done = "response.output_item.done"


class Type96(Enum):
    response_output_text_annotation_added = "response.output_text.annotation.added"


class ResponseOutputTextAnnotationAddedEvent(BaseModel):
    type: Literal["ResponseOutputTextAnnotationAddedEvent"] = Field(
        ...,
        description="The type of the event. Always 'response.output_text.annotation.added'.",
    )
    item_id: str = Field(
        ...,
        description="The unique identifier of the item to which the annotation is being added.",
    )
    output_index: int = Field(
        ..., description="The index of the output item in the response's output array."
    )
    content_index: int = Field(
        ..., description="The index of the content part within the output item."
    )
    annotation_index: int = Field(
        ..., description="The index of the annotation within the content part."
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    annotation: Dict[str, Any] = Field(
        ...,
        description="The annotation object being added. (See annotation schema for details.)",
    )


class ResponsePromptVariables(BaseModel):
    __root__: Optional[
        Dict[str, Union[str, InputTextContent, InputImageContent, InputFileContent]]
    ]


class Truncation(Enum):
    auto = "auto"
    disabled = "disabled"


class Type97(Enum):
    response_queued = "response.queued"


class Type98(Enum):
    response_reasoning_summary_part_added = "response.reasoning_summary_part.added"


class Type99(Enum):
    summary_text = "summary_text"


class Part(BaseModel):
    type: Type99 = Field(
        ..., description="The type of the summary part. Always `summary_text`."
    )
    text: str = Field(..., description="The text of the summary part.")


class ResponseReasoningSummaryPartAddedEvent(BaseModel):
    type: Literal["ResponseReasoningSummaryPartAddedEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_summary_part.added`.\n",
    )
    item_id: str = Field(
        ..., description="The ID of the item this summary part is associated with.\n"
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this summary part is associated with.\n",
    )
    summary_index: int = Field(
        ..., description="The index of the summary part within the reasoning summary.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )
    part: Part = Field(..., description="The summary part that was added.\n")


class Type100(Enum):
    response_reasoning_summary_part_done = "response.reasoning_summary_part.done"


class Type101(Enum):
    summary_text = "summary_text"


class Part1(BaseModel):
    type: Type101 = Field(
        ..., description="The type of the summary part. Always `summary_text`."
    )
    text: str = Field(..., description="The text of the summary part.")


class ResponseReasoningSummaryPartDoneEvent(BaseModel):
    type: Literal["ResponseReasoningSummaryPartDoneEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_summary_part.done`.\n",
    )
    item_id: str = Field(
        ..., description="The ID of the item this summary part is associated with.\n"
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this summary part is associated with.\n",
    )
    summary_index: int = Field(
        ..., description="The index of the summary part within the reasoning summary.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )
    part: Part1 = Field(..., description="The completed summary part.\n")


class Type102(Enum):
    response_reasoning_summary_text_delta = "response.reasoning_summary_text.delta"


class ResponseReasoningSummaryTextDeltaEvent(BaseModel):
    type: Literal["ResponseReasoningSummaryTextDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_summary_text.delta`.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the item this summary text delta is associated with.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this summary text delta is associated with.\n",
    )
    summary_index: int = Field(
        ..., description="The index of the summary part within the reasoning summary.\n"
    )
    delta: str = Field(
        ..., description="The text delta that was added to the summary.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class Type103(Enum):
    response_reasoning_summary_text_done = "response.reasoning_summary_text.done"


class ResponseReasoningSummaryTextDoneEvent(BaseModel):
    type: Literal["ResponseReasoningSummaryTextDoneEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_summary_text.done`.\n",
    )
    item_id: str = Field(
        ..., description="The ID of the item this summary text is associated with.\n"
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this summary text is associated with.\n",
    )
    summary_index: int = Field(
        ..., description="The index of the summary part within the reasoning summary.\n"
    )
    text: str = Field(
        ..., description="The full text of the completed reasoning summary.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class Type104(Enum):
    response_reasoning_text_delta = "response.reasoning_text.delta"


class ResponseReasoningTextDeltaEvent(BaseModel):
    type: Literal["ResponseReasoningTextDeltaEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_text.delta`.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the item this reasoning text delta is associated with.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this reasoning text delta is associated with.\n",
    )
    content_index: int = Field(
        ...,
        description="The index of the reasoning content part this delta is associated with.\n",
    )
    delta: str = Field(
        ..., description="The text delta that was added to the reasoning content.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class Type105(Enum):
    response_reasoning_text_done = "response.reasoning_text.done"


class ResponseReasoningTextDoneEvent(BaseModel):
    type: Literal["ResponseReasoningTextDoneEvent"] = Field(
        ...,
        description="The type of the event. Always `response.reasoning_text.done`.\n",
    )
    item_id: str = Field(
        ..., description="The ID of the item this reasoning text is associated with.\n"
    )
    output_index: int = Field(
        ...,
        description="The index of the output item this reasoning text is associated with.\n",
    )
    content_index: int = Field(
        ..., description="The index of the reasoning content part.\n"
    )
    text: str = Field(
        ..., description="The full text of the completed reasoning content.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class Type106(Enum):
    response_refusal_delta = "response.refusal.delta"


class ResponseRefusalDeltaEvent(BaseModel):
    type: Literal["ResponseRefusalDeltaEvent"] = Field(
        ..., description="The type of the event. Always `response.refusal.delta`.\n"
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the refusal text is added to.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the refusal text is added to.\n",
    )
    content_index: int = Field(
        ...,
        description="The index of the content part that the refusal text is added to.\n",
    )
    delta: str = Field(..., description="The refusal text that is added.\n")
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class Type107(Enum):
    response_refusal_done = "response.refusal.done"


class ResponseRefusalDoneEvent(BaseModel):
    type: Literal["ResponseRefusalDoneEvent"] = Field(
        ..., description="The type of the event. Always `response.refusal.done`.\n"
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the refusal text is finalized.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the refusal text is finalized.\n",
    )
    content_index: int = Field(
        ...,
        description="The index of the content part that the refusal text is finalized.\n",
    )
    refusal: str = Field(..., description="The refusal text that is finalized.\n")
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )


class ResponseStreamOptions1(BaseModel):
    include_obfuscation: Optional[bool] = Field(
        None,
        description="When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events to\nnormalize payload sizes as a mitigation to certain side-channel attacks.\nThese obfuscation fields are included by default, but add a small amount\nof overhead to the data stream. You can set `include_obfuscation` to\nfalse to optimize for bandwidth if you trust the network links between\nyour application and the OpenAI API.\n",
    )


class ResponseStreamOptions(BaseModel):
    __root__: Optional[ResponseStreamOptions1]


class Type108(Enum):
    response_output_text_delta = "response.output_text.delta"


class ResponseTextDeltaEvent(BaseModel):
    type: Literal["ResponseTextDeltaEvent"] = Field(
        ..., description="The type of the event. Always `response.output_text.delta`.\n"
    )
    item_id: str = Field(
        ..., description="The ID of the output item that the text delta was added to.\n"
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the text delta was added to.\n",
    )
    content_index: int = Field(
        ...,
        description="The index of the content part that the text delta was added to.\n",
    )
    delta: str = Field(..., description="The text delta that was added.\n")
    sequence_number: int = Field(..., description="The sequence number for this event.")
    logprobs: List[ResponseLogProb] = Field(
        ..., description="The log probabilities of the tokens in the delta.\n"
    )


class Type109(Enum):
    response_output_text_done = "response.output_text.done"


class ResponseTextDoneEvent(BaseModel):
    type: Literal["ResponseTextDoneEvent"] = Field(
        ..., description="The type of the event. Always `response.output_text.done`.\n"
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the text content is finalized.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the text content is finalized.\n",
    )
    content_index: int = Field(
        ...,
        description="The index of the content part that the text content is finalized.\n",
    )
    text: str = Field(..., description="The text content that is finalized.\n")
    sequence_number: int = Field(..., description="The sequence number for this event.")
    logprobs: List[ResponseLogProb] = Field(
        ..., description="The log probabilities of the tokens in the delta.\n"
    )


class InputTokensDetails(BaseModel):
    cached_tokens: int = Field(
        ...,
        description="The number of tokens that were retrieved from the cache. \n[More on prompt caching](https://platform.openai.com/docs/guides/prompt-caching).\n",
    )


class OutputTokensDetails(BaseModel):
    reasoning_tokens: int = Field(..., description="The number of reasoning tokens.")


class ResponseUsage(BaseModel):
    input_tokens: int = Field(..., description="The number of input tokens.")
    input_tokens_details: InputTokensDetails = Field(
        ..., description="A detailed breakdown of the input tokens."
    )
    output_tokens: int = Field(..., description="The number of output tokens.")
    output_tokens_details: OutputTokensDetails = Field(
        ..., description="A detailed breakdown of the output tokens."
    )
    total_tokens: int = Field(..., description="The total number of tokens used.")


class Type110(Enum):
    response_web_search_call_completed = "response.web_search_call.completed"


class ResponseWebSearchCallCompletedEvent(BaseModel):
    type: Literal["ResponseWebSearchCallCompletedEvent"] = Field(
        ...,
        description="The type of the event. Always `response.web_search_call.completed`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the web search call is associated with.\n",
    )
    item_id: str = Field(
        ...,
        description="Unique ID for the output item associated with the web search call.\n",
    )
    sequence_number: int = Field(
        ..., description="The sequence number of the web search call being processed."
    )


class Type111(Enum):
    response_web_search_call_in_progress = "response.web_search_call.in_progress"


class ResponseWebSearchCallInProgressEvent(BaseModel):
    type: Literal["ResponseWebSearchCallInProgressEvent"] = Field(
        ...,
        description="The type of the event. Always `response.web_search_call.in_progress`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the web search call is associated with.\n",
    )
    item_id: str = Field(
        ...,
        description="Unique ID for the output item associated with the web search call.\n",
    )
    sequence_number: int = Field(
        ..., description="The sequence number of the web search call being processed."
    )


class Type112(Enum):
    response_web_search_call_searching = "response.web_search_call.searching"


class ResponseWebSearchCallSearchingEvent(BaseModel):
    type: Literal["ResponseWebSearchCallSearchingEvent"] = Field(
        ...,
        description="The type of the event. Always `response.web_search_call.searching`.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the web search call is associated with.\n",
    )
    item_id: str = Field(
        ...,
        description="Unique ID for the output item associated with the web search call.\n",
    )
    sequence_number: int = Field(
        ..., description="The sequence number of the web search call being processed."
    )


class Type113(Enum):
    screenshot = "screenshot"


class Screenshot(BaseModel):
    type: Literal["Screenshot"] = Field(
        ...,
        description="Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n",
    )


class Type114(Enum):
    scroll = "scroll"


class Scroll(BaseModel):
    type: Literal["Scroll"] = Field(
        ...,
        description="Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n",
    )
    x: int = Field(..., description="The x-coordinate where the scroll occurred.\n")
    y: int = Field(..., description="The y-coordinate where the scroll occurred.\n")
    scroll_x: int = Field(..., description="The horizontal scroll distance.\n")
    scroll_y: int = Field(..., description="The vertical scroll distance.\n")


class SearchContextSize(Enum):
    low = "low"
    medium = "medium"
    high = "high"


class ServiceTier1(Enum):
    auto = "auto"
    default = "default"
    flex = "flex"
    scale = "scale"
    priority = "priority"


class ServiceTier(BaseModel):
    __root__: Optional[ServiceTier1]


class Type115(Enum):
    summary_text = "summary_text"


class SummaryModel(BaseModel):
    type: Type115 = Field(
        ..., description="The type of the object. Always `summary_text`."
    )
    text: str = Field(
        ..., description="A summary of the reasoning output from the model so far."
    )


class Type116(Enum):
    json_schema = "json_schema"


class TextResponseFormatJsonSchema(BaseModel):
    type: Literal["TextResponseFormatJsonSchema"] = Field(
        ...,
        description="The type of response format being defined. Always `json_schema`.",
    )
    description: Optional[str] = Field(
        None,
        description="A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n",
    )
    name: str = Field(
        ...,
        description="The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n",
    )
    schema_: ResponseFormatJsonSchemaSchema = Field(..., alias="schema")
    strict: Optional[bool] = None


class Type117(Enum):
    allowed_tools = "allowed_tools"


class Mode(Enum):
    auto = "auto"
    required = "required"


class ToolChoiceAllowed(BaseModel):
    type: Literal["ToolChoiceAllowed"] = Field(
        ..., description="Allowed tool configuration type. Always `allowed_tools`."
    )
    mode: Mode = Field(
        ...,
        description="Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n",
    )
    tools: List[Dict[str, Any]] = Field(
        ...,
        description='A list of tool definitions that the model should be allowed to call.\n\nFor the Responses API, the list of tool definitions might look like:\n```json\n[\n  { "type": "function", "name": "get_weather" },\n  { "type": "mcp", "server_label": "deepwiki" },\n  { "type": "image_generation" }\n]\n```\n',
    )


class Type118(Enum):
    custom = "custom"


class ToolChoiceCustom(BaseModel):
    type: Literal["ToolChoiceCustom"] = Field(
        ..., description="For custom tool calling, the type is always `custom`."
    )
    name: str = Field(..., description="The name of the custom tool to call.")


class Type119(Enum):
    function = "function"


class ToolChoiceFunction(BaseModel):
    type: Literal["ToolChoiceFunction"] = Field(
        ..., description="For function calling, the type is always `function`."
    )
    name: str = Field(..., description="The name of the function to call.")


class Type120(Enum):
    mcp = "mcp"


class ToolChoiceMCP(BaseModel):
    type: Literal["ToolChoiceMCP"] = Field(
        ..., description="For MCP tools, the type is always `mcp`."
    )
    server_label: str = Field(..., description="The label of the MCP server to use.\n")
    name: Optional[str] = None


class ToolChoiceOptions(Enum):
    none = "none"
    auto = "auto"
    required = "required"


class Type121(Enum):
    file_search = "file_search"
    web_search_preview = "web_search_preview"
    computer_use_preview = "computer_use_preview"
    web_search_preview_2025_03_11 = "web_search_preview_2025_03_11"
    image_generation = "image_generation"
    code_interpreter = "code_interpreter"


class ToolChoiceTypes(BaseModel):
    type: Literal["ToolChoiceTypes"] = Field(
        ...,
        description="The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `image_generation`\n",
    )


class TopLogProb(BaseModel):
    token: str
    logprob: float
    bytes: List[int]


class Type122(Enum):
    type = "type"


class TypeModel(BaseModel):
    type: Literal["Type"] = Field(
        ...,
        description="Specifies the event type. For a type action, this property is \nalways set to `type`.\n",
    )
    text: str = Field(..., description="The text to type.\n")


class Type123(Enum):
    url_citation = "url_citation"


class UrlCitationBody(BaseModel):
    type: Literal["UrlCitationBody"] = Field(
        ..., description="The type of the URL citation. Always `url_citation`."
    )
    url: str = Field(..., description="The URL of the web resource.")
    start_index: int = Field(
        ...,
        description="The index of the first character of the URL citation in the message.",
    )
    end_index: int = Field(
        ...,
        description="The index of the last character of the URL citation in the message.",
    )
    title: str = Field(..., description="The title of the web resource.")


class VectorStoreFileAttributes(BaseModel):
    __root__: Optional[Dict[str, Union[constr(max_length=512), float, bool]]]


class Verbosity1(Enum):
    low = "low"
    medium = "medium"
    high = "high"


class Verbosity(BaseModel):
    __root__: Optional[Verbosity1]


class Type124(Enum):
    wait = "wait"


class Wait(BaseModel):
    type: Literal["Wait"] = Field(
        ...,
        description="Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n",
    )


class Type125(Enum):
    find = "find"


class WebSearchActionFind(BaseModel):
    type: Literal["WebSearchActionFind"] = Field(..., description="The action type.\n")
    url: AnyUrl = Field(
        ..., description="The URL of the page searched for the pattern.\n"
    )
    pattern: str = Field(
        ..., description="The pattern or text to search for within the page.\n"
    )


class Type126(Enum):
    open_page = "open_page"


class WebSearchActionOpenPage(BaseModel):
    type: Literal["WebSearchActionOpenPage"] = Field(
        ..., description="The action type.\n"
    )
    url: AnyUrl = Field(..., description="The URL opened by the model.\n")


class Type127(Enum):
    search = "search"


class Type128(Enum):
    url = "url"


class Source(BaseModel):
    type: Type128 = Field(..., description="The type of source. Always `url`.\n")
    url: str = Field(..., description="The URL of the source.\n")


class WebSearchActionSearch(BaseModel):
    type: Literal["WebSearchActionSearch"] = Field(
        ..., description="The action type.\n"
    )
    query: str = Field(..., description="The search query.\n")
    sources: Optional[List[Source]] = Field(
        None,
        description="The sources used in the search.\n",
        title="Web search sources",
    )


class Type129(Enum):
    approximate = "approximate"


class WebSearchApproximateLocation1(BaseModel):
    type: Optional[Type129] = Field(
        "approximate",
        description="The type of location approximation. Always `approximate`.",
    )
    country: Optional[str] = None
    region: Optional[str] = None
    city: Optional[str] = None
    timezone: Optional[str] = None


class WebSearchApproximateLocation(BaseModel):
    __root__: Optional[WebSearchApproximateLocation1]


class Type130(Enum):
    web_search_preview = "web_search_preview"
    web_search_preview_2025_03_11 = "web_search_preview_2025_03_11"


class WebSearchPreviewTool(BaseModel):
    type: Literal["WebSearchPreviewTool"] = Field(
        ...,
        description="The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`.",
    )
    user_location: Optional[ApproximateLocation] = None
    search_context_size: Optional[SearchContextSize] = Field(
        None,
        description="High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.",
    )


class Type131(Enum):
    web_search = "web_search"
    web_search_2025_08_26 = "web_search_2025_08_26"


class Filters1(BaseModel):
    allowed_domains: Optional[List[str]] = None


class WebSearchTool(BaseModel):
    type: Literal["WebSearchTool"] = Field(
        ...,
        description="The type of the web search tool. One of `web_search` or `web_search_2025_08_26`.",
    )
    filters: Optional[Filters1] = None
    user_location: Optional[WebSearchApproximateLocation] = None
    search_context_size: Optional[SearchContextSize] = Field(
        "medium",
        description="High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.",
    )


class Type132(Enum):
    web_search_call = "web_search_call"


class Status11(Enum):
    in_progress = "in_progress"
    searching = "searching"
    completed = "completed"
    failed = "failed"


class WebSearchToolCall(BaseModel):
    id: str = Field(..., description="The unique ID of the web search tool call.\n")
    type: Literal["WebSearchToolCall"] = Field(
        ...,
        description="The type of the web search tool call. Always `web_search_call`.\n",
    )
    status: Status11 = Field(
        ..., description="The status of the web search tool call.\n"
    )
    action: Union[
        WebSearchActionSearch, WebSearchActionOpenPage, WebSearchActionFind
    ] = Field(
        ...,
        description="An object describing the specific action taken in this web search call.\nIncludes details on how the model used the web (search, open_page, find).\n",
        discriminator="type",
    )


class Annotation(BaseModel):
    __root__: Union[
        FileCitationBody, UrlCitationBody, ContainerFileCitationBody, FilePath
    ] = Field(..., discriminator="type")


class ComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Type7 = Field(
        ...,
        description="Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n",
    )
    key: str = Field(..., description="The key to compare against the value.")
    value: Union[str, float, bool, List[ComparisonFilterValueItems]] = Field(
        ...,
        description="The value to compare against the attribute key; supports string, number, or boolean types.",
    )


class CompoundFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Type8 = Field(..., description="Type of operation: `and` or `or`.")
    filters: List[Union[ComparisonFilter, Any]] = Field(
        ...,
        description="Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`.",
    )


class ComputerCallOutputItemParam(BaseModel):
    id: Optional[str] = None
    call_id: constr(min_length=1, max_length=64) = Field(
        ..., description="The ID of the computer tool call that produced the output."
    )
    type: Literal["ComputerCallOutputItemParam"] = Field(
        ...,
        description="The type of the computer tool call output. Always `computer_call_output`.",
    )
    output: ComputerScreenshotImage
    acknowledged_safety_checks: Optional[List[ComputerCallSafetyCheckParam]] = None
    status: Optional[FunctionCallItemStatus] = None


class CustomGrammarFormatParam(BaseModel):
    type: Literal["CustomGrammarFormatParam"] = Field(
        ..., description="Grammar format. Always `grammar`."
    )
    syntax: GrammarSyntax1 = Field(
        ...,
        description="The syntax of the grammar definition. One of `lark` or `regex`.",
    )
    definition: str = Field(..., description="The grammar definition.")


class CustomToolParam(BaseModel):
    type: Literal["CustomToolParam"] = Field(
        ..., description="The type of the custom tool. Always `custom`."
    )
    name: str = Field(
        ...,
        description="The name of the custom tool, used to identify it in tool calls.",
    )
    description: Optional[str] = Field(
        None,
        description="Optional description of the custom tool, used to provide more context.",
    )
    format: Optional[Union[CustomTextFormatParam, CustomGrammarFormatParam]] = Field(
        None,
        description="The input format for the custom tool. Default is unconstrained text.",
        discriminator="type",
    )


class Drag(BaseModel):
    type: Literal["Drag"] = Field(
        ...,
        description="Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n",
    )
    path: List[DragPoint] = Field(
        ...,
        description="An array of coordinates representing the path of the drag action. Coordinates will appear as an array\nof objects, eg\n```\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```\n",
    )


class Result(BaseModel):
    file_id: Optional[str] = Field(None, description="The unique ID of the file.\n")
    text: Optional[str] = Field(
        None, description="The text that was retrieved from the file.\n"
    )
    filename: Optional[str] = Field(None, description="The name of the file.\n")
    attributes: Optional[VectorStoreFileAttributes] = None
    score: Optional[float] = Field(
        None, description="The relevance score of the file - a value between 0 and 1.\n"
    )


class FileSearchToolCall(BaseModel):
    id: str = Field(..., description="The unique ID of the file search tool call.\n")
    type: Literal["FileSearchToolCall"] = Field(
        ...,
        description="The type of the file search tool call. Always `file_search_call`.\n",
    )
    status: Status2 = Field(
        ...,
        description="The status of the file search tool call. One of `in_progress`,\n`searching`, `incomplete` or `failed`,\n",
    )
    queries: List[str] = Field(
        ..., description="The queries used to search for files.\n"
    )
    results: Optional[List[Result]] = None


class Filters(BaseModel):
    __root__: Union[ComparisonFilter, CompoundFilter]


class FunctionAndCustomToolCallOutput(BaseModel):
    __root__: Union[InputTextContent, InputImageContent, InputFileContent] = Field(
        ..., discriminator="type"
    )


class Output(BaseModel):
    __root__: Union[
        InputTextContentParam, InputImageContentParamAutoParam, InputFileContentParam
    ] = Field(..., discriminator="type")


class FunctionCallOutputItemParam(BaseModel):
    id: Optional[str] = None
    call_id: constr(min_length=1, max_length=64) = Field(
        ...,
        description="The unique ID of the function tool call generated by the model.",
    )
    type: Literal["FunctionCallOutputItemParam"] = Field(
        ...,
        description="The type of the function tool call output. Always `function_call_output`.",
    )
    output: Union[constr(max_length=10485760), List[Output]] = Field(
        ..., description="Text, image, or file output of the function tool call."
    )
    status: Optional[FunctionCallItemStatus] = None


class ImageGenTool(BaseModel):
    type: Literal["ImageGenTool"] = Field(
        ...,
        description="The type of the image generation tool. Always `image_generation`.\n",
    )
    model: Optional[Model] = Field(
        "gpt-image-1",
        description="The image generation model to use. Default: `gpt-image-1`.\n",
    )
    quality: Optional[Quality] = Field(
        "auto",
        description="The quality of the generated image. One of `low`, `medium`, `high`,\nor `auto`. Default: `auto`.\n",
    )
    size: Optional[Size] = Field(
        "auto",
        description="The size of the generated image. One of `1024x1024`, `1024x1536`,\n`1536x1024`, or `auto`. Default: `auto`.\n",
    )
    output_format: Optional[OutputFormat] = Field(
        "png",
        description="The output format of the generated image. One of `png`, `webp`, or\n`jpeg`. Default: `png`.\n",
    )
    output_compression: Optional[conint(ge=0, le=100)] = Field(
        100, description="Compression level for the output image. Default: 100.\n"
    )
    moderation: Optional[Moderation] = Field(
        "auto",
        description="Moderation level for the generated image. Default: `auto`.\n",
    )
    background: Optional[Background] = Field(
        "auto",
        description="Background type for the generated image. One of `transparent`,\n`opaque`, or `auto`. Default: `auto`.\n",
    )
    input_fidelity: Optional[InputFidelity] = None
    input_image_mask: Optional[InputImageMask] = Field(
        None,
        description="Optional mask for inpainting. Contains `image_url`\n(string, optional) and `file_id` (string, optional).\n",
    )
    partial_images: Optional[conint(ge=0, le=3)] = Field(
        0,
        description="Number of partial images to generate in streaming mode, from 0 (default value) to 3.\n",
    )


class InputContent(BaseModel):
    __root__: Union[
        InputTextContent, InputImageContent, InputFileContent, InputAudio
    ] = Field(..., discriminator="type")


class InputMessageContentList(BaseModel):
    __root__: List[InputContent] = Field(
        ...,
        description="A list of one or many input items to the model, containing different content \ntypes.\n",
        title="Input item content list",
    )


class LogProb(BaseModel):
    token: str
    logprob: float
    bytes: List[int]
    top_logprobs: List[TopLogProb]


class MCPListTools(BaseModel):
    type: Literal["MCPListTools"] = Field(
        ..., description="The type of the item. Always `mcp_list_tools`.\n"
    )
    id: str = Field(..., description="The unique ID of the list.\n")
    server_label: str = Field(..., description="The label of the MCP server.\n")
    tools: List[MCPListToolsTool] = Field(
        ..., description="The tools available on the server.\n"
    )
    error: Optional[str] = None


class RequireApproval(BaseModel):
    class Config:
        extra = Extra.forbid

    always: Optional[MCPToolFilter] = None
    never: Optional[MCPToolFilter] = None


class MCPTool(BaseModel):
    type: Literal["MCPTool"] = Field(
        ..., description="The type of the MCP tool. Always `mcp`."
    )
    server_label: str = Field(
        ...,
        description="A label for this MCP server, used to identify it in tool calls.\n",
    )
    server_url: Optional[str] = Field(
        None,
        description="The URL for the MCP server. One of `server_url` or `connector_id` must be\nprovided.\n",
    )
    connector_id: Optional[ConnectorId] = Field(
        None,
        description="Identifier for service connectors, like those available in ChatGPT. One of\n`server_url` or `connector_id` must be provided. Learn more about service\nconnectors [here](https://platform.openai.com/docs/guides/tools-remote-mcp#connectors).\n\nCurrently supported `connector_id` values are:\n\n- Dropbox: `connector_dropbox`\n- Gmail: `connector_gmail`\n- Google Calendar: `connector_googlecalendar`\n- Google Drive: `connector_googledrive`\n- Microsoft Teams: `connector_microsoftteams`\n- Outlook Calendar: `connector_outlookcalendar`\n- Outlook Email: `connector_outlookemail`\n- SharePoint: `connector_sharepoint`\n",
    )
    authorization: Optional[str] = Field(
        None,
        description="An OAuth access token that can be used with a remote MCP server, either\nwith a custom MCP server URL or a service connector. Your application\nmust handle the OAuth authorization flow and provide the token here.\n",
    )
    server_description: Optional[str] = Field(
        None,
        description="Optional description of the MCP server, used to provide more context.\n",
    )
    headers: Optional[Dict[str, str]] = None
    allowed_tools: Optional[Union[List[str], MCPToolFilter]] = None
    require_approval: Optional[Union[RequireApproval, RequireApproval1]] = None


class MCPToolCall(BaseModel):
    type: Literal["MCPToolCall"] = Field(
        ..., description="The type of the item. Always `mcp_call`.\n"
    )
    id: str = Field(..., description="The unique ID of the tool call.\n")
    server_label: str = Field(
        ..., description="The label of the MCP server running the tool.\n"
    )
    name: str = Field(..., description="The name of the tool that was run.\n")
    arguments: str = Field(
        ..., description="A JSON string of the arguments passed to the tool.\n"
    )
    output: Optional[str] = None
    error: Optional[str] = None
    status: Optional[MCPToolCallStatus] = Field(
        None,
        description="The status of the tool call. One of `in_progress`, `completed`, `incomplete`, `calling`, or `failed`.\n",
    )
    approval_request_id: Optional[str] = None


class ModelIdsResponses(BaseModel):
    __root__: Union[ModelIdsShared, ModelIdsResponses1] = Field(..., example="gpt-4o")


class ModelResponseProperties(BaseModel):
    metadata: Optional[Metadata] = None
    top_logprobs: Optional[conint(ge=0, le=20)] = None
    temperature: Optional[confloat(ge=0.0, le=2.0)] = None
    top_p: Optional[confloat(ge=0.0, le=1.0)] = None
    user: Optional[str] = Field(
        None,
        description="This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n",
        example="user-1234",
    )
    safety_identifier: Optional[str] = Field(
        None,
        description="A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n",
        example="safety-identifier-1234",
    )
    prompt_cache_key: Optional[str] = Field(
        None,
        description="Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n",
        example="prompt-cache-key-1234",
    )
    service_tier: Optional[ServiceTier] = None


class OutputTextContent(BaseModel):
    type: Literal["OutputTextContent"] = Field(
        ..., description="The type of the output text. Always `output_text`."
    )
    text: str = Field(..., description="The text output from the model.")
    annotations: List[Annotation] = Field(
        ..., description="The annotations of the text output."
    )
    logprobs: Optional[List[LogProb]] = None


class Prompt1(BaseModel):
    id: str = Field(
        ..., description="The unique identifier of the prompt template to use."
    )
    version: Optional[str] = None
    variables: Optional[ResponsePromptVariables] = None


class Prompt(BaseModel):
    __root__: Optional[Prompt1]


class Reasoning(BaseModel):
    effort: Optional[ReasoningEffort] = None
    summary: Optional[Summary] = None
    generate_summary: Optional[GenerateSummary] = None


class ReasoningItem(BaseModel):
    type: Literal["ReasoningItem"] = Field(
        ..., description="The type of the object. Always `reasoning`.\n"
    )
    id: str = Field(
        ..., description="The unique identifier of the reasoning content.\n"
    )
    encrypted_content: Optional[str] = None
    summary: List[SummaryModel] = Field(..., description="Reasoning summary content.\n")
    content: Optional[List[ReasoningTextContent]] = Field(
        None, description="Reasoning text content.\n"
    )
    status: Optional[Status5] = Field(
        None,
        description="The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n",
    )


class ResponseError1(BaseModel):
    code: ResponseErrorCode
    message: str = Field(
        ..., description="A human-readable description of the error.\n"
    )


class ResponseError(BaseModel):
    __root__: Optional[ResponseError1]


class TextResponseFormatConfiguration(BaseModel):
    __root__: Union[
        ResponseFormatText, TextResponseFormatJsonSchema, ResponseFormatJsonObject
    ] = Field(
        ...,
        description='An object specifying the format that the model must output.\n\nConfiguring `{ "type": "json_schema" }` enables Structured Outputs, \nwhich ensures the model will match your supplied JSON schema. Learn more in the \n[Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nThe default format is `{ "type": "text" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ "type": "json_object" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n',
        discriminator="type",
    )


class ComputerAction(BaseModel):
    __root__: Union[
        ClickParam,
        DoubleClickAction,
        Drag,
        KeyPressAction,
        Move,
        Screenshot,
        Scroll,
        TypeModel,
        Wait,
    ] = Field(..., discriminator="type")


class ComputerToolCall(BaseModel):
    type: Literal["ComputerToolCall"] = Field(
        ..., description="The type of the computer call. Always `computer_call`."
    )
    id: str = Field(..., description="The unique ID of the computer call.")
    call_id: str = Field(
        ...,
        description="An identifier used when responding to the tool call with output.\n",
    )
    action: ComputerAction
    pending_safety_checks: List[ComputerCallSafetyCheckParam] = Field(
        ..., description="The pending safety checks for the computer call.\n"
    )
    status: Status1 = Field(
        ...,
        description="The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n",
    )


class CreateModelResponseProperties(ModelResponseProperties):
    top_logprobs: Optional[conint(ge=0, le=20)] = Field(
        None,
        description="An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n",
    )


class CustomToolCallOutput(BaseModel):
    type: Literal["CustomToolCallOutput"] = Field(
        ...,
        description="The type of the custom tool call output. Always `custom_tool_call_output`.\n",
    )
    id: Optional[str] = Field(
        None,
        description="The unique ID of the custom tool call output in the OpenAI platform.\n",
    )
    call_id: str = Field(
        ...,
        description="The call ID, used to map this custom tool call output to a custom tool call.\n",
    )
    output: Union[str, List[FunctionAndCustomToolCallOutput]] = Field(
        ...,
        description="The output from the custom tool call generated by your code.\nCan be a string or an list of output content.\n",
    )


class EasyInputMessage(BaseModel):
    role: Role = Field(
        ...,
        description="The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n",
    )
    content: Union[str, InputMessageContentList] = Field(
        ...,
        description="Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n",
    )
    type: Literal["EasyInputMessage"] = Field(
        ..., description="The type of the message input. Always `message`.\n"
    )


class FileSearchTool(BaseModel):
    type: Literal["FileSearchTool"] = Field(
        ..., description="The type of the file search tool. Always `file_search`."
    )
    vector_store_ids: List[str] = Field(
        ..., description="The IDs of the vector stores to search."
    )
    max_num_results: Optional[int] = Field(
        None,
        description="The maximum number of results to return. This number should be between 1 and 50 inclusive.",
    )
    ranking_options: Optional[RankingOptions] = Field(
        None, description="Ranking options for search."
    )
    filters: Optional[Filters] = None


class InputMessage(BaseModel):
    type: Literal["InputMessage"] = Field(
        ..., description="The type of the message input. Always set to `message`.\n"
    )
    role: Role1 = Field(
        ...,
        description="The role of the message input. One of `user`, `system`, or `developer`.\n",
    )
    status: Optional[Status5] = Field(
        None,
        description="The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n",
    )
    content: InputMessageContentList


class OutputContent(BaseModel):
    __root__: Union[OutputTextContent, RefusalContent, ReasoningTextContent] = Field(
        ..., discriminator="type"
    )


class OutputMessageContent(BaseModel):
    __root__: Union[OutputTextContent, RefusalContent] = Field(
        ..., discriminator="type"
    )


class ResponseContentPartAddedEvent(BaseModel):
    type: Literal["ResponseContentPartAddedEvent"] = Field(
        ...,
        description="The type of the event. Always `response.content_part.added`.\n",
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the content part was added to.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the content part was added to.\n",
    )
    content_index: int = Field(
        ..., description="The index of the content part that was added.\n"
    )
    part: OutputContent = Field(..., description="The content part that was added.\n")
    sequence_number: int = Field(..., description="The sequence number of this event.")


class ResponseContentPartDoneEvent(BaseModel):
    type: Literal["ResponseContentPartDoneEvent"] = Field(
        ..., description="The type of the event. Always `response.content_part.done`.\n"
    )
    item_id: str = Field(
        ...,
        description="The ID of the output item that the content part was added to.\n",
    )
    output_index: int = Field(
        ...,
        description="The index of the output item that the content part was added to.\n",
    )
    content_index: int = Field(
        ..., description="The index of the content part that is done.\n"
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    part: OutputContent = Field(..., description="The content part that is done.\n")


class Text(BaseModel):
    format: Optional[TextResponseFormatConfiguration] = None
    verbosity: Optional[Verbosity] = None


class Tool(BaseModel):
    __root__: Union[
        FunctionTool,
        FileSearchTool,
        ComputerUsePreviewTool,
        WebSearchTool,
        MCPTool,
        CodeInterpreterTool,
        ImageGenTool,
        LocalShellToolParam,
        CustomToolParam,
        WebSearchPreviewTool,
    ] = Field(
        ...,
        description="A tool that can be used to generate a response.\n",
        discriminator="type",
    )


class OutputMessage(BaseModel):
    id: str = Field(..., description="The unique ID of the output message.\n")
    type: Literal["OutputMessage"] = Field(
        ..., description="The type of the output message. Always `message`.\n"
    )
    role: Role2 = Field(
        ..., description="The role of the output message. Always `assistant`.\n"
    )
    content: List[OutputMessageContent] = Field(
        ..., description="The content of the output message.\n"
    )
    status: Status5 = Field(
        ...,
        description="The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n",
    )


class ResponseProperties(BaseModel):
    previous_response_id: Optional[str] = None
    model: Optional[ModelIdsResponses] = Field(
        None,
        description="Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n",
    )
    reasoning: Optional[Reasoning] = None
    background: Optional[bool] = None
    max_output_tokens: Optional[int] = None
    max_tool_calls: Optional[int] = None
    text: Optional[Text] = Field(
        None,
        description="Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n",
    )
    tools: Optional[List[Tool]] = Field(
        None,
        description="An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](https://platform.openai.com/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n",
    )
    tool_choice: Optional[
        Union[
            ToolChoiceOptions,
            ToolChoiceAllowed,
            ToolChoiceTypes,
            ToolChoiceFunction,
            ToolChoiceMCP,
            ToolChoiceCustom,
        ]
    ] = Field(
        None,
        description="How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n",
        discriminator="type",
    )
    prompt: Optional[Prompt] = None
    truncation: Optional[Truncation] = None


class Item(BaseModel):
    __root__: Union[
        InputMessage,
        OutputMessage,
        FileSearchToolCall,
        ComputerToolCall,
        ComputerCallOutputItemParam,
        WebSearchToolCall,
        FunctionToolCall,
        FunctionCallOutputItemParam,
        ReasoningItem,
        ImageGenToolCall,
        CodeInterpreterToolCall,
        LocalShellToolCall,
        LocalShellToolCallOutput,
        MCPListTools,
        MCPApprovalRequest,
        MCPApprovalResponse,
        MCPToolCall,
        CustomToolCallOutput,
        CustomToolCall,
    ] = Field(
        ...,
        description="Content item used to generate a response.\n",
        discriminator="type",
    )


class OutputItem(BaseModel):
    __root__: Union[
        OutputMessage,
        FileSearchToolCall,
        FunctionToolCall,
        WebSearchToolCall,
        ComputerToolCall,
        ReasoningItem,
        ImageGenToolCall,
        CodeInterpreterToolCall,
        LocalShellToolCall,
        MCPToolCall,
        MCPListTools,
        MCPApprovalRequest,
        CustomToolCall,
    ] = Field(..., discriminator="type")


class ResponseOutputItemAddedEvent(BaseModel):
    type: Literal["ResponseOutputItemAddedEvent"] = Field(
        ..., description="The type of the event. Always `response.output_item.added`.\n"
    )
    output_index: int = Field(
        ..., description="The index of the output item that was added.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )
    item: OutputItem = Field(..., description="The output item that was added.\n")


class ResponseOutputItemDoneEvent(BaseModel):
    type: Literal["ResponseOutputItemDoneEvent"] = Field(
        ..., description="The type of the event. Always `response.output_item.done`.\n"
    )
    output_index: int = Field(
        ..., description="The index of the output item that was marked done.\n"
    )
    sequence_number: int = Field(
        ..., description="The sequence number of this event.\n"
    )
    item: OutputItem = Field(..., description="The output item that was marked done.\n")


class InputItem(BaseModel):
    __root__: Union[EasyInputMessage, Item, ItemReferenceParam] = Field(
        ..., discriminator="type"
    )


class Response(ModelResponseProperties, ResponseProperties):
    id: str = Field(..., description="Unique identifier for this Response.\n")
    object: Object = Field(
        ...,
        description="The object type of this resource - always set to `response`.\n",
    )
    status: Optional[Status10] = Field(
        None,
        description="The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n",
    )
    created_at: float = Field(
        ...,
        description="Unix timestamp (in seconds) of when this Response was created.\n",
    )
    error: ResponseError
    incomplete_details: Optional[IncompleteDetails]
    output: List[OutputItem] = Field(
        ...,
        description="An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n",
    )
    instructions: Optional[Union[str, List[InputItem]]]
    output_text: Optional[str] = None
    usage: Optional[ResponseUsage] = None
    parallel_tool_calls: bool = Field(
        ..., description="Whether to allow the model to run tool calls in parallel.\n"
    )
    conversation: Optional[Conversation2] = None


class ResponseCompletedEvent(BaseModel):
    type: Literal["ResponseCompletedEvent"] = Field(
        ..., description="The type of the event. Always `response.completed`.\n"
    )
    response: Response = Field(
        ..., description="Properties of the completed response.\n"
    )
    sequence_number: int = Field(..., description="The sequence number for this event.")


class ResponseCreatedEvent(BaseModel):
    type: Literal["ResponseCreatedEvent"] = Field(
        ..., description="The type of the event. Always `response.created`.\n"
    )
    response: Response = Field(..., description="The response that was created.\n")
    sequence_number: int = Field(..., description="The sequence number for this event.")


class ResponseFailedEvent(BaseModel):
    type: Literal["ResponseFailedEvent"] = Field(
        ..., description="The type of the event. Always `response.failed`.\n"
    )
    sequence_number: int = Field(..., description="The sequence number of this event.")
    response: Response = Field(..., description="The response that failed.\n")


class ResponseInProgressEvent(BaseModel):
    type: Literal["ResponseInProgressEvent"] = Field(
        ..., description="The type of the event. Always `response.in_progress`.\n"
    )
    response: Response = Field(..., description="The response that is in progress.\n")
    sequence_number: int = Field(..., description="The sequence number of this event.")


class ResponseIncompleteEvent(BaseModel):
    type: Literal["ResponseIncompleteEvent"] = Field(
        ..., description="The type of the event. Always `response.incomplete`.\n"
    )
    response: Response = Field(..., description="The response that was incomplete.\n")
    sequence_number: int = Field(..., description="The sequence number of this event.")


class ResponseQueuedEvent(BaseModel):
    type: Literal["ResponseQueuedEvent"] = Field(
        ..., description="The type of the event. Always 'response.queued'."
    )
    response: Response = Field(
        ..., description="The full response object that is queued."
    )
    sequence_number: int = Field(..., description="The sequence number for this event.")


class ResponseStreamEvent(BaseModel):
    __root__: Union[
        ResponseAudioDeltaEvent,
        ResponseAudioDoneEvent,
        ResponseAudioTranscriptDeltaEvent,
        ResponseAudioTranscriptDoneEvent,
        ResponseCodeInterpreterCallCodeDeltaEvent,
        ResponseCodeInterpreterCallCodeDoneEvent,
        ResponseCodeInterpreterCallCompletedEvent,
        ResponseCodeInterpreterCallInProgressEvent,
        ResponseCodeInterpreterCallInterpretingEvent,
        ResponseCompletedEvent,
        ResponseContentPartAddedEvent,
        ResponseContentPartDoneEvent,
        ResponseCreatedEvent,
        ResponseErrorEvent,
        ResponseFileSearchCallCompletedEvent,
        ResponseFileSearchCallInProgressEvent,
        ResponseFileSearchCallSearchingEvent,
        ResponseFunctionCallArgumentsDeltaEvent,
        ResponseFunctionCallArgumentsDoneEvent,
        ResponseInProgressEvent,
        ResponseFailedEvent,
        ResponseIncompleteEvent,
        ResponseOutputItemAddedEvent,
        ResponseOutputItemDoneEvent,
        ResponseReasoningSummaryPartAddedEvent,
        ResponseReasoningSummaryPartDoneEvent,
        ResponseReasoningSummaryTextDeltaEvent,
        ResponseReasoningSummaryTextDoneEvent,
        ResponseReasoningTextDeltaEvent,
        ResponseReasoningTextDoneEvent,
        ResponseRefusalDeltaEvent,
        ResponseRefusalDoneEvent,
        ResponseTextDeltaEvent,
        ResponseTextDoneEvent,
        ResponseWebSearchCallCompletedEvent,
        ResponseWebSearchCallInProgressEvent,
        ResponseWebSearchCallSearchingEvent,
        ResponseImageGenCallCompletedEvent,
        ResponseImageGenCallGeneratingEvent,
        ResponseImageGenCallInProgressEvent,
        ResponseImageGenCallPartialImageEvent,
        ResponseMCPCallArgumentsDeltaEvent,
        ResponseMCPCallArgumentsDoneEvent,
        ResponseMCPCallCompletedEvent,
        ResponseMCPCallFailedEvent,
        ResponseMCPCallInProgressEvent,
        ResponseMCPListToolsCompletedEvent,
        ResponseMCPListToolsFailedEvent,
        ResponseMCPListToolsInProgressEvent,
        ResponseOutputTextAnnotationAddedEvent,
        ResponseQueuedEvent,
        ResponseCustomToolCallInputDeltaEvent,
        ResponseCustomToolCallInputDoneEvent,
    ] = Field(..., discriminator="type")


class CreateResponse(CreateModelResponseProperties, ResponseProperties):
    input: Optional[Union[str, List[InputItem]]] = Field(
        None,
        description="Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Image inputs](https://platform.openai.com/docs/guides/images)\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\n",
    )
    include: Optional[List[IncludeEnum]] = None
    parallel_tool_calls: Optional[bool] = None
    store: Optional[bool] = None
    instructions: Optional[str] = None
    stream: Optional[bool] = None
    stream_options: Optional[ResponseStreamOptions] = None
    conversation: Optional[Union[str, ConversationParam]] = None
